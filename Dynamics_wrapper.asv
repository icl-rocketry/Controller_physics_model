function y_dot = Dynamics_wrapper(t, y, control_signal, config.Isp)
m, CoM, J = Get_inertia_and_mass(config.m_dry, config.m_fuel, config.CoM_wet, config.CoM_dry, config.J_wet, config.J_dry);
q = y(7:10);
q = q / norm(q); 
R_BI = quat2rotm(q');

F_thrust_body, tau_thrust_body = Engine_Model(); 
F_aero_body, tau_aero_body = Aero_Model();
y_dot = Get_state_derivative(t, y, R_BI, J, F_thrust_body, tau_thrust_body, F_aero_body, tau_aero_body, config.Isp, con)

end

function y_dot = Rocket_Dynamics_Wrapper(t, y, controls, config)
    % Unpack Config
    g0 = 9.81;
    Isp = 280; % Or config.Isp

    % 1. Calculate Dependent Variables based on THIS y
    % (Mass, Inertia, Rotation Matrix)
    mass = y(14);
    fuel_mass = max(0, mass - config.m_dry);
    
    % Interpolate Inertia and CoM
    pct = fuel_mass / config.m_fuel_max;
    J = config.J_dry + pct * (config.J_wet - config.J_dry);
    CoM_z = config.CoM_dry_z + pct * (config.CoM_wet_z - config.CoM_dry_z);
    
    % Update Rotation Matrix
    q = y(7:10);
    q = q / norm(q); % Safety normalize
    R_BI = quat2rotm(q'); % Requires Robotics Toolbox or custom function
    % If no toolbox, use the custom implementation provided below
    
    % 2. Calculate Forces (Recalculate for every sub-step!)
    % Engine
    [F_thrust, tau_thrust] = Engine_Model(controls, CoM_z); 
    
    % Aero (Depends on current velocity y(4:6))
    [F_aero, tau_aero] = Aero_Model(y, CoM_z, config);
    
    % 3. Call your Derivative Function
    y_dot = Get_state_derivative(t, y, R_BI, J, F_thrust, tau_thrust, F_aero, tau_aero, Isp, g0);
end