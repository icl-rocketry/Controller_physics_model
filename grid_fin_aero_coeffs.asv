function [] = grid_fin_aero_coeffs(V_B, w_B, cg_pos, chord_gridfin, Sref_gridfin, R_body, x_gridfin, GF_actuation, rho, aerosplinefits)
% Calculates the aerodynamic ceoff contributions from the gridfins

    % gridfin angles about x axis
    G_angle_1 = 0.0;
    G_angle_2 = (2/3) * pi;
    G_angle_3 = (4/3) * pi;
    G_angle = [G_angle_1, G_angle_2, G_angle_3];

    % create coefficient list
    C_F = zeros(3, 3);
    C_M = zeros(3, 3);


    for idx = 1:3
        % distance from cg to geometric gentre of gridfin (approximate cp)
        R_centre = R_body + chord_gridfin / 2;
    
        % distance of cg to geometric centre of the grid fin
        r_gridfin = [x_gridfin - cg_pos(1); R_centre * sin(G_angle(idx)) - cg_pos(2); R_centre * cos(G_angle(idx)) - cg_pos(3)];
    
        % Use transport theorem to get fin velocity
        V_F_B = V_B + cross(w_B, r_gridfin);
    
        % Body -> Hinge rotation matrices
        RBH = [1, 0, 0; 0, cos(G_angle(idx)), -sin(G_angle(idx)); 0, sin(G_angle(idx)), cos(G_angle(idx))];
    
        % Hinge -> Fin rotation matrices
        RHF = [cos(GF_actuation(idx)), sin(GF_actuation(idx)), 0; -sin(GF_actuation(idx)), cos(GF_actuation(idx)), 0; 0, 0, 1];
      
        % Rotating fin velocities into hinge reference
        V_H = RBH * V_F_B;
    
        % Rotating fin velocities into fin reference
        V_F = RHF * V_H;
    
        % Aero section - approximations used so come back to this when we have wind tunnel data
        % for now grid fins are modelled as quasi-axisymetric which is a
        % valid assumption but is not perfectly accurate so change this
        % when we have data fro gridfins in beta and alpha
        
        % get velocities
        U = V_F(1);
        V = V_F(2);
        W = V_F(3);
        
        % get transverse total velocity
        V_transverse = sqrt(V ^ 2 + W ^ 2);

        % get total angle of attack and decomposition angle for y and z
        alpha_total = atan2(V_transverse, U);
        phi_aero = atan2(W, V);

        % obtain dynamic pressure
        qinf = 0.5 * rho * norm(V_F) ^ 2;

        % get aero coeffs
        CL = ppval(aerosplinefits.CLfit, alpha_total);
        CD = ppval(aerosplinefits.CDfit, alpha_total);

        % get L and D
        L = CL * qinf * Sref_gridfin;
        D = CD * qinf * Sref_gridfin;

        % get axial and transverse forces
        F_axial = D * cos(alpha_total) - L * sin(alpha_total);
        F_transverse = L * cos(alpha_total) + D * sin(alpha_total);

        % decompose forces
        Fx = -F_axial;
        Fy = F_transverse * cos(phi_aero);
        Fz = F_transverse * sin(phi_aero);
        F_F = [Fx; Fy; Fz];

        % tranform back to body axes
        F_H = transpose(RHF) * F_F;
        F_B = transpose(RBH) * F_H;
        M_B = cross(r_gridfin, F_B);

        % convert back to coeffients
        CF() = F_B ./ (qinf * Sref_gridfin);
        CM() = M_B ./ (qinf * Sref_gridfin);
    end 





    
    

    % V_hingeframe = T(rotation from fin 1 to n in x axis) * ( V_B + w_B * r_gridfin)
    V_H_1 = [1,0,0; 0, 1, 0 ; 0, 0 , 1] * (V_B + cross(w_B, r_gridfin_1));
    V_H_2 = [1,0,0; 0, cos(G_angle_2), sin(G_angle_2) ; 0, -sin(G_angle_2) , cos(G_angle_2)] * (V_B + cross(w_B, r_gridfin_2));
    V_H_3 = [1,0,0; 0, cos(G_angle_3), sin(G_angle_3) ; 0, -sin(G_angle_3) , cos(G_angle_3)] * (V_B + cross(w_B, r_gridfin_3));

    %apply gridfin control deflection (deflections d1 to d3 in radians)
    %(rotate in z)
    V_G_1 = [cos(d1), -sin(d1), 0; sin(d1), cos(d1), 0; 0, 0, 1] * V_H_1;
    V_G_2 = [cos(d2), -sin(d2), 0; sin(d2), cos(d2), 0; 0, 0, 1] * V_H_2;
    V_G_3 = [cos(d3), -sin(d3), 0; sin(d3), cos(d3), 0; 0, 0, 1] * V_H_3;

    %angles of attack in fin frame
    alpha_G1 = atan(V_G_1(2)/V_G_1(1)); %not 100% sure of axes definition here 
    alpha_G2 = atan(V_G_2(2)/V_G_2(1));
    alpha_G3 = atan(V_G_3(2)/V_G_3(1));

    %Coefficients(alpha, M):
    CL_G1 = ppval(aerosplinefits.CLfit, alpha_G1);
    CL_G2 = ppval(aerosplinefits.CLfit, alpha_G2);
    CL_G3 = ppval(aerosplinefits.CLfit, alpha_G3);

    CD_G1 = ppval(aerosplinefits.CDfit, alpha_G1);
    CD_G2 = ppval(aerosplinefits.CDfit, alpha_G2);
    CD_G3 = ppval(aerosplinefits.CDfit, alpha_G3);

    %redimensionalise to forcess
    h = state(3); %in m?
    h0 = 40; %based off of approximate euroc location
    h = h + h0; 
    [~,~,~,rho] = atmosisa(h);

    qinf_1 = 0.5*rho*norm(V_G_1)^2;
    L_G1 = CL_G1*(qinf_1 * chord_gridfins); %redimensionalised relatiive to chord not area, unsure
    D_G1 = CD_G1*(qinf_1 * chord_gridfins);
    
    qinf_2 = 0.5*rho*norm(V_G_2)^2;
    L_G2 = CL_G2*(qinf_2 * chord_gridfins);
    D_G2 = CD_G2*(qinf_2 * chord_gridfins);
        
    qinf_3 = 0.5*rho*norm(V_G_3)^2;
    L_G3 = CL_G3*(qinf_3 * chord_gridfins);
    D_G3 = CD_G3*(qinf_3 * chord_gridfins);

    %forcing vectors in fin frame
    F_1_G = [L_G1*sin(alpha_G1)+D_G1*cos(alpha_G1); L_G1*cos(alpha_G1) - D_G1*sin(alpha_G1); 0];
    F_2_G = [L_G2*sin(alpha_G2)+D_G2*cos(alpha_G2); L_G2*cos(alpha_G2) - D_G2*sin(alpha_G2); 0];
    F_3_G = [L_G3*sin(alpha_G3)+D_G3*cos(alpha_G3); L_G3*cos(alpha_G3) - D_G3*sin(alpha_G3); 0];

    %transfer to forcing coefficients in body axes:

    %unrotate gridfin control deflection about z, to hinge frame:
    F_1_H = [cos(-d1), -sin(-d1), 0; sin(-d1), cos(-d1), 0; 0, 0, 1] * F_1_G;
    F_2_H = [cos(-d2), -sin(-d2), 0; sin(-d2), cos(-d2), 0; 0, 0, 1] * F_2_G;
    F_3_H = [cos(-d3), -sin(-d3), 0; sin(-d3), cos(-d3), 0; 0, 0, 1] * F_3_G;

    %rotate back about x axis back to gridfin 1
    F_1_B = F_1_H;
    F_2_B = [1,0,0; 0, cos(-G_angle_2), sin(-G_angle_2) ; 0, -sin(-G_angle_2) , cos(-G_angle_2)] * F_2_H;
    F_3_B = [1,0,0; 0, cos(-G_angle_3), sin(-G_angle_3) ; 0, -sin(-G_angle_3) , cos(-G_angle_2)] * F_3_H;
    %x,y,z are now aligned with rocket x,y,z
   
    %non dimensionalise force vectors relative to rocket qinf and Sref 
    CF_1_B = F_1_B./(0.5*rho*(norm(V_B)^2)*Sref);
    CF_2_B = F_2_B./(0.5*rho*(norm(V_B)^2)*Sref);
    CF_3_B = F_3_B./(0.5*rho*(norm(V_B)^2)*Sref);
    
    %force coefficients: just sum to rocket coefficents
    C_A = C_A + CF_1_B(1) + CF_2_B(1) + CF_3_B(1); %x and A aligned
    C_Y = C_Y + CF_1_B(2) + CF_2_B(2) + CF_3_B(2); %y and Y aligned
    C_N = C_N + CF_1_B(3) + CF_2_B(3) + CF_3_B(3); %z and N aligned

    %moments: using forcing vectors at each hinge
    C_M_allgridfins = cross(r_gridfin_1, F_1_H) + cross(r_gridfin_2, F_2_H) + cross(r_gridfin_3, F_3_H);
end

